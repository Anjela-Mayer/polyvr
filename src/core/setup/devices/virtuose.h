#ifndef VIRTUOSE_H_INCLUDED
#define VIRTUOSE_H_INCLUDED
#include <virtuose/virtuoseAPI.h>

#include <OpenSG/OSGVector.h>
#include <OpenSG/OSGMatrix.h>
#include <OpenSG/OSGGLUT.h>


#include <list>
#include "core/objects/VRTransform.h"
#include "core/objects/geometry/VRPhysics.h"
#include "core/networking/VRSharedMemory.h"


OSG_BEGIN_NAMESPACE;
using namespace std;

class virtuose {
    public:
        struct Vec9 {
            float data[9] = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f};
        };

        struct Vec7 {
            float data[7] = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,1.0f};
        };

        struct Vec6 {
            float data[6] = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f};
        };

    private:
        FILE* deamon = 0;
        Vec6 targetForces;
        Vec7 targetPosition;
        Vec6 targetSpeed;
        VRSharedMemory interface;
        bool isAttached = false;
        /** attached Object*/
        VRTransformPtr attached = 0;
        /** represents the haptic's center in the virtual scene **/
        VRTransformPtr base = 0;

        /** haptic timestep **/
        float timestep;
        /** user generated force **/
        Vec3d totalForce;

        /** diff between frames (used to avoid build-ups)**/
        Vec3d pPos;
        Vec3d sPos;
        Vec3d sRot;

        VirtCommandType commandType = COMMAND_TYPE_NONE;
        float gripperPosition = 0;
        float gripperSpeed = 0;

    public:
        virtuose();
        ~virtuose();

        bool connected();
        void connect(string IP,float timestep = 0.002f);
        void disconnect();

        void setSimulationScales(float translation, float forces);


        Matrix4d getPose(float f[7]);
        Matrix4d getPose();

        /**returns force generated by the user**/
        Vec3d getForce();
        /**
        Applies given Force/Torque on the haptic
        **/
        void applyForce(Vec3d force, Vec3d torque);
        /** parses position/rotation data of given VRPhysics into the given float[7] array**/
        void fillPosition(VRPhysics* p, float *to, VRPhysics* origin);
        /** parses speed data of given VRPhysics into the given float[6] array**/
        void fillSpeed(VRPhysics* p, float *to,VRPhysics* origin);
        /** parses given btMatrix3x3 into the given float[9] array**/
        void Matrix3ToArray(btMatrix3x3 m, float *to);
        /** sets the base **/
        void setBase(VRTransformPtr tBase);
        /**connect a physicalized Object to this virtuose and push it in the same direction the virtuose moves.**/
        void attachTransform(VRTransformPtr trans);
        /** detach the previously attached Transform and returns it**/
        VRTransformPtr detachTransform();
        /** update functions of the Virtuose, have to be called each frame**/
        void updateVirtMechPre();
        void updateVirtMechPost();
        /** 1 means button pressed, 0 means released**/
        Vec3i getButtonStates();

        void enableForceFeedback(bool enable);
};

OSG_END_NAMESPACE;

#endif // VIRTUOSE_H_INCLUDED
